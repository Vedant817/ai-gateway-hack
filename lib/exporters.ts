import { PuzzleInstance, ModelSolution, ScheduledMeeting } from '@/types/game';

export function exportToJSON(puzzle: PuzzleInstance, solution: ModelSolution): string {
  const exportData = {
    puzzle: {
      id: puzzle.id,
      type: puzzle.type,
      difficulty: puzzle.difficulty,
      objective: puzzle.objective,
      persona: puzzle.persona,
    },
    solution: {
      modelId: solution.modelId,
      scheduledMeetings: solution.scheduledMeetings,
      explanation: solution.explanation,
      exportedAt: new Date().toISOString(),
    },
    metadata: {
      totalMeetings: solution.scheduledMeetings.length,
      participants: puzzle.participants.map((p) => p.name),
    },
  };

  return JSON.stringify(exportData, null, 2);
}

export function exportToCSV(puzzle: PuzzleInstance, solution: ModelSolution): string {
  const headers = ['Meeting ID', 'Meeting Name', 'Start Time', 'End Time', 'Duration (min)', 'Participants'];
  const rows: string[][] = [headers];

  solution.scheduledMeetings.forEach((scheduled) => {
    const meeting = puzzle.meetings.find((m) => m.id === scheduled.meetingId);
    const meetingName = meeting?.name || scheduled.meetingId;
    const start = new Date(scheduled.startTime);
    const end = new Date(scheduled.endTime);
    const duration = Math.round((end.getTime() - start.getTime()) / (1000 * 60));
    const participants = scheduled.participants
      .map((pid) => {
        const p = puzzle.participants.find((p) => p.id === pid);
        return p?.name || pid;
      })
      .join('; ');

    rows.push([
      scheduled.meetingId,
      meetingName,
      start.toLocaleString(),
      end.toLocaleString(),
      duration.toString(),
      participants,
    ]);
  });

  return rows.map((row) => row.map((cell) => `"${cell}"`).join(',')).join('\n');
}

export function exportToCalendar(puzzle: PuzzleInstance, solution: ModelSolution): string {
  // Generate iCal format
  let ical = 'BEGIN:VCALENDAR\n';
  ical += 'VERSION:2.0\n';
  ical += 'PRODID:-//Constraint Coliseum//AI Planner Arena//EN\n';
  ical += `X-WR-CALNAME:${puzzle.persona?.name || 'Scheduled Meetings'}\n`;

  solution.scheduledMeetings.forEach((scheduled) => {
    const meeting = puzzle.meetings.find((m) => m.id === scheduled.meetingId);
    const meetingName = meeting?.name || scheduled.meetingId;
    const start = new Date(scheduled.startTime);
    const end = new Date(scheduled.endTime);
    const participants = scheduled.participants
      .map((pid) => {
        const p = puzzle.participants.find((p) => p.id === pid);
        return p?.name || pid;
      })
      .join(', ');

    ical += 'BEGIN:VEVENT\n';
    ical += `DTSTART:${start.toISOString().replace(/[-:]/g, '').split('.')[0]}Z\n`;
    ical += `DTEND:${end.toISOString().replace(/[-:]/g, '').split('.')[0]}Z\n`;
    ical += `SUMMARY:${meetingName}\n`;
    ical += `DESCRIPTION:Participants: ${participants}\\nGenerated by ${solution.modelId}\n`;
    ical += `UID:${puzzle.id}-${scheduled.meetingId}@constraint-coliseum\n`;
    ical += 'END:VEVENT\n';
  });

  ical += 'END:VCALENDAR\n';
  return ical;
}

export function exportSolution(
  puzzle: PuzzleInstance,
  solution: ModelSolution,
  format: 'json' | 'csv' | 'calendar'
): string {
  switch (format) {
    case 'json':
      return exportToJSON(puzzle, solution);
    case 'csv':
      return exportToCSV(puzzle, solution);
    case 'calendar':
      return exportToCalendar(puzzle, solution);
    default:
      return exportToJSON(puzzle, solution);
  }
}

